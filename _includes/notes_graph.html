<style>
  /* keep CSS from overriding node/text color; JS will set colors */
  @media (prefers-color-scheme: light) {
    .links line { stroke: #b0cef2; opacity: .5; }
    .nodes circle { cursor: pointer; transition: all .15s ease-out; }
    .text text { cursor: pointer; }
    #graph-wrapper { background: #faf4e5; border-radius: 4px; height: auto; }
  }
  @media (prefers-color-scheme: dark) {
    .links line { stroke: #b0cef2; opacity: .5; }
    .nodes circle { cursor: pointer; transition: all .15s ease-out; }
    .text text { cursor: pointer; text-shadow:
      -1px -1px 0 #faf4e5bb, 1px -1px 0 #faf4e5bb,
      -1px  1px 0 #faf4e5bb,-1px  1px 0 #faf4e5bb; }
    #graph-wrapper { background: #333333; border-radius: 4px; height: auto; }
  }
  .inactive { opacity: .1; transition: all .15s ease-out; }
  #graph-wrapper > svg { max-width: 100%; display: block; }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", function loadGraph() {
      var s = document.createElement("script");
      s.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      s.crossOrigin = "anonymous";
      s.integrity = "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(s);

      s.onload = function () {
        const MIN_NODE = 8, MAX_NODE = 12, ACTIVE_R = 1.5;
        const STROKE = 1, FONT_SIZE = 16, FONT_BASELINE = 40, MAX_LABEL = 50;

        const graphData = {% include notes_graph.json %};
        let nodesData = graphData.nodes || [];
        let linksData = graphData.edges || [];

        function linkIds(l) {
          const sid = (l.source && typeof l.source === 'object') ? l.source.id : (l.source ?? l.from);
          const tid = (l.target && typeof l.target === 'object') ? l.target.id : (l.target ?? l.to);
          return [sid, tid];
        }

        const degree = new Map();
        nodesData.forEach(n => degree.set(n.id, 0));
        linksData.forEach(l => {
          const [sid, tid] = linkIds(l);
          if (sid != null) degree.set(sid, (degree.get(sid) || 0) + 1);
          if (tid != null) degree.set(tid, (degree.get(tid) || 0) + 1);
        });

        const nodeSize = {};
        nodesData.forEach(n => {
          let w = 3 * Math.sqrt((degree.get(n.id) || 0) + 1);
          nodeSize[n.id] = Math.max(MIN_NODE, Math.min(MAX_NODE, w));
        });

        function isCurrentPath(notePath) {
          if (!notePath) return false;
          const norm = s => String(s).replace(/\/+$/, '');
          return norm(window.location.pathname) === norm(notePath);
        }

        function isPage(d) {
          const coll = (d.collection || '').toLowerCase();
          if (coll === 'pages') return true;
          const p = ((d.path || d.url || '') + '').toLowerCase();
          return /(\/|^)_?pages\//.test(p);
        }

        function isSourceNote(d) {
          const raw = (d.path || d.url || '').toString();
          const p = decodeURIComponent(raw).toLowerCase();
          if (/(^|\/)\+\s*sources\//.test(p)) return true;
          if (Array.isArray(d.tags) && d.tags.map(t=>t.toLowerCase()).includes('sources')) return true;
          return false;
        }

        function isGhost(d) { return d.ghost === true || d.exists === false; }
        function isDarkTheme(){
          return document.documentElement.classList.contains('theme-dark')
              || window.matchMedia('(prefers-color-scheme: dark)').matches;
        }

        function activeNodeColor(){ return isDarkTheme() ? '#faf4e5' : '#333333'; }
        function defaultLabelColor(){ return isDarkTheme() ? '#faf4e5' : '#100f0f'; }

        function nodeColor(d) {
  if (isCurrentPath(d.path)) return activeNodeColor(); // active node
  if (d.collection === 'posts' || d.kind === 'post') return '#4caf50'; // posts = green
  if (isPage(d)) return '#ff7eb6';   // pages = pink
  if (isSourceNote(d)) return '#ffd166'; // sources = yellow
  return '#b0cef2';                  // default blue
}

        function labelColor(d){
          if (isCurrentPath(d.path)) return activeNodeColor();
          return defaultLabelColor();
        }

        function nodeOpacity(d) {
          if (isCurrentPath(d.path)) return 1;
          if (isGhost(d)) return 0.35;
          return 1;
        }

        function shorten(str, maxLen, sep=' ') {
          if (str.length <= maxLen) return str;
          const cut = str.lastIndexOf(sep, maxLen);
          return (cut > 0 ? str.substr(0, cut) : str.substr(0, maxLen)) + 'â€¦';
        }

        const wrap = document.getElementById('graph-wrapper');
        const svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgEl.setAttribute("width", wrap.getBoundingClientRect().width);
        svgEl.setAttribute("height", Math.max(320, window.innerHeight * 0.8));
        wrap.appendChild(svgEl);
        const svg = d3.select(svgEl);
        const width = +svg.attr('width');
        const height = +svg.attr('height');

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const simulation = d3.forceSimulation(nodesData)
          .force("forceX", d3.forceX(width / 2).strength(0.05))
          .force("forceY", d3.forceY(height / 2).strength(0.05))
          .force("charge", d3.forceManyBody().strength(-200))
          .force("link", d3.forceLink(linksData).id(d => d.id).distance(110).strength(0.7))
          .force("collision", d3.forceCollide().radius(d => (nodeSize[d.id] || 12) + 24).iterations(2))
          .on("tick", ticked);

        function dragstarted(d) {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x; d.fy = d.y;
        }
        function dragged(d) {
          d.fx = d3.event.x; d.fy = d3.event.y;
        }
        function dragended(d) {
          if (!d3.event.active) simulation.alphaTarget(0);
          d.fx = null; d.fy = null;
        }

        function onClick(d){ if (d.path) window.location = d.path; }
        function onMouseover(d) {
          const related = new Set();
          linksData.forEach(n => {
            const [sid, tid] = linkIds(n);
            if (sid == d.id || tid == d.id) { related.add(sid); related.add(tid); }
          });
          node.attr("class", nd => (nd.id !== d.id && !related.has(nd.id)) ? "inactive" : "");
          link.attr("class", ld => {
            const [sid, tid] = linkIds(ld);
            return (sid !== d.id && tid !== d.id) ? "inactive" : "";
          });
          link.attr("stroke-width", ld => {
            const [sid, tid] = linkIds(ld);
            return (sid === d.id || tid === d.id) ? STROKE * 4 : STROKE;
          });
          text.attr("class", td => (td.id !== d.id && !related.has(td.id)) ? "inactive" : "");
        }
        function onMouseout() {
          node.attr("class",""); link.attr("class",""); text.attr("class","");
          link.attr("stroke-width", STROKE);
        }

        function restart() {
          node = node.data(nodesData, d => d.id);
          node.exit().remove();
          node = node.enter()
            .append("circle")
            .attr("r", d => nodeSize[d.id])
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended))
            .merge(node);

          node
            .style('fill', nodeColor)
            .style('opacity', nodeOpacity)
            .attr('stroke', '#222')
            .attr('stroke-width', d => isCurrentPath(d.path) ? 1.25 : 0.5)
            .attr('active', d => isCurrentPath(d.path) ? true : null);

          link = link.data(linksData, d => linkIds(d).join('-'));
          link.exit().remove();
          link = link.enter()
            .append("line")
            .attr("stroke-width", STROKE)
            .merge(link);

          text = text.data(nodesData, d => d.label);
          text.exit().remove();
          text = text.enter()
            .append("text")
            .text(d => shorten(d.label.replace(/_*/g, ""), MAX_LABEL))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

          text
            .style('fill', labelColor)
            .style('opacity', nodeOpacity)
            .attr('active', d => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);
          simulation.alpha(0.8).restart();
        }

        function ticked() {
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          text
            .attr("x", d => d.x)
            .attr("y", d => d.y - (FONT_BASELINE - nodeSize[d.id]));
          link
            .attr("x1", d => (d.source.x))
            .attr("y1", d => (d.source.y))
            .attr("x2", d => (d.target.x))
            .attr("y2", d => (d.target.y));
        }

        svg.call(d3.zoom().scaleExtent([0.2, 3]).on("zoom", function() {
          g.attr("transform", d3.event.transform);
        }));

        restart();

        window.addEventListener('resize', function () {
          svgEl.setAttribute("width", wrap.getBoundingClientRect().width);
          svgEl.setAttribute("height", Math.max(320, window.innerHeight * 0.8));
        });

        // Listen for theme changes
        window.matchMedia('(prefers-color-scheme: dark)')
          .addEventListener('change', () => restart());
        const mo = new MutationObserver(() => restart());
        mo.observe(document.documentElement, { attributes:true, attributeFilter:['class'] });
      };
    });
  </script>
</div>