<style>
  /* Light theme */
  @media (prefers-color-scheme: light) {
    .links line {
      stroke: #b0cef2; /* other notes */
      opacity: 0.5;
    }
  .nodes circle {
  cursor: pointer;
  transition: all 0.15s ease-out;
}
/* no fill here – JS sets it */
.text text {
  cursor: pointer;
  /* no fill here – JS sets it */
}
    #graph-wrapper {
      background: #faf4e5; /* graph background */
      border-radius: 4px;
      height: auto;
    }
  }

  /* Dark theme */
  @media (prefers-color-scheme: dark) {
    .links line {
      stroke: #b0cef2;
      opacity: 0.5;
    }
    .nodes circle {
      cursor: pointer;
      transition: all 0.15s ease-out;
    }
    .nodes [active],
    .text [active] {
      cursor: pointer;
      fill: #333333; /* current note */
    }
    .text text {
      cursor: pointer;
      text-shadow: -1px -1px 0 #faf4e5bb, 1px -1px 0 #faf4e5bb,
                   -1px 1px 0 #faf4e5bb, 1px 1px 0 #faf4e5bb;
    }
    #graph-wrapper {
      background: #333333;
      border-radius: 4px;
      height: auto;
    }
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>
<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      oScript.onload = () => {
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 12;
        const ACTIVE_RADIUS_FACTOR = 1.5;
        const STROKE = 1;
        const FONT_SIZE = 16;
        const TICKS = 200;
        const FONT_BASELINE = 40;
        const MAX_LABEL_LENGTH = 50;

        const graphData = {% include notes_graph.json %}
        let nodesData = graphData.nodes;
        let linksData = graphData.edges;

        // Build a set of all site pages' URLs (from Jekyll), normalized (no trailing slash)
const PAGE_URLS = new Set(
  ({{ site.pages | map: 'url' | jsonify }})
    .map(u => String(u || '').replace(/\/+$/, ''))
);

// --- Degree map (handles multiple link shapes: source/target OR from/to)
const degree = new Map();
nodesData.forEach(n => degree.set(n.id, 0));
linksData.forEach(l => {
  const sid = (typeof l.source === 'object') ? l.source.id
            : (l.source ?? l.from);
  const tid = (typeof l.target === 'object') ? l.target.id
            : (l.target ?? l.to);
  if (sid != null) degree.set(sid, (degree.get(sid) || 0) + 1);
  if (tid != null) degree.set(tid, (degree.get(tid) || 0) + 1);
});

// --- Type helpers (robust to your data shape)
function isPost(d) {
  if (d.collection) return d.collection === 'posts';
  return !!(d.url && /^\/\d{4}\//.test(d.url)); // /YYYY/...
}
function isNote(d) {
  if (d.collection) return d.collection === 'notes';
  return !!(d.url && d.url.startsWith('/notes/'));
}
function isPage(d) {
  // Prefer URL, fall back to path; normalize trailing slashes
  const u = String(d.url || d.path || '').replace(/\/+$/, '');
  // also try with a leading slash (in case d.url is missing it)
  const uSlash = u.startsWith('/') ? u : '/' + u;
  return PAGE_URLS.has(u) || PAGE_URLS.has(uSlash);
}
function isGhost(d) {
  return d.ghost === true || d.exists === false;
}
function isActive(d) {
  return isCurrentPath(d.path);
}

// Colors / opacity
function nodeColor(d) {
  if (isActive(d)) return '#333333';   // active
  if (isPage(d))   return '#ff7eb6';   // pages = pink
  return '#b0cef2';                    // everything else = blue
}
function nodeOpacity(d) {
  if (isActive(d)) return 1.0;
  if (isGhost(d))  return 0.35;        // ghosts faint
  return 1.0;                          // keep all others solid for now
}
        const nodeSize = {};

        const updateNodeSize = () => {
          nodesData.forEach((el) => {
            let weight =
              3 *
              Math.sqrt(
                linksData.filter((l) => l.source.id === el.id || l.target.id === el.id)
                  .length + 1
              );
            if (weight < MINIMAL_NODE_SIZE) {
              weight = MINIMAL_NODE_SIZE;
            } else if (weight > MAX_NODE_SIZE) {
              weight = MAX_NODE_SIZE;
            }
            nodeSize[el.id] = weight;
          });
        };

        const onClick = (d) => {
          window.location = d.path
        };

        const onMouseover = function (d) {
          const relatedNodesSet = new Set();
          linksData
            .filter((n) => n.target.id == d.id || n.source.id == d.id)
            .forEach((n) => {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", (node_d) => {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", (link_d) => {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", (link_d) => {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 4;
            }
            return STROKE;
          });
          text.attr("class", (text_d) => {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        };

        const onMouseout = function (d) {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        };

        const sameNodes = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const map = new Map();
          for (const node of previous) {
            map.set(node.id, node.label);
          }

          for (const node of next) {
            const found = map.get(node.id);
            if (!found || found !== node.title) {
              return false;
            }
          }

          return true;
        };

        const sameEdges = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const set = new Set();
          for (const edge of previous) {
            set.add(`${edge.source.id}-${edge.target.id}`);
          }

          for (const edge of next) {
            if (!set.has(`${edge.source.id}-${edge.target.id}`)) {
              return false;
            }
          }

          return true;
        };

        const graphWrapper = document.getElementById('graph-wrapper')
        const element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        element.setAttribute("width", graphWrapper.getBoundingClientRect().width);
        element.setAttribute("height", window.innerHeight * 0.8);
        graphWrapper.appendChild(element);

        const reportWindowSize = () => {
          element.setAttribute("width", window.innerWidth);
          element.setAttribute("height", window.innerHeight);
        };

        window.onresize = reportWindowSize;

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));
        let zoomLevel = 1;

        const simulation = d3
          .forceSimulation(nodesData)
          .force("forceX", d3.forceX().x(width / 2))
          .force("forceY", d3.forceY().y(height / 2))
          .force("charge", d3.forceManyBody())
          .force(
            "link",
            d3
              .forceLink(linksData)
              .id((d) => d.id)
              .distance(70)
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(80))
          .stop();

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const resize = () => {
          if (d3.event) {
            const scale = d3.event.transform;
            zoomLevel = scale.k;
            g.attr("transform", scale);
          }

          const zoomOrKeep = (value) => (zoomLevel >= 1 ? value / zoomLevel : value);

          const font = Math.max(Math.round(zoomOrKeep(FONT_SIZE)), 1);

          text.attr("font-size", (d) => font);
          text.attr("y", (d) => d.y - zoomOrKeep(FONT_BASELINE) + 8);
          link.attr("stroke-width", zoomOrKeep(STROKE));
          node.attr("r", (d) => {
            return zoomOrKeep(nodeSize[d.id]);
          });
          svg
            .selectAll("circle")
            .filter((_d, i, nodes) => d3.select(nodes[i]).attr("active"))
            .attr("r", (d) => zoomOrKeep(ACTIVE_RADIUS_FACTOR * nodeSize[d.id]));
        };

        const ticked = () => {
          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          text
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - (FONT_BASELINE - nodeSize[d.id]) / zoomLevel);
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        };

        const restart = () => {
          updateNodeSize();
          node = node.data(nodesData, (d) => d.id);
          node.exit().remove();
          node = node
            .enter()
            .append("circle")
            .attr("r", (d) => {
              return nodeSize[d.id];
            })
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(node);

            // apply colors/opacity now that the circles exist
node
  .attr('fill', nodeColor)
  .attr('opacity', nodeOpacity)
  .attr('stroke', '#222')                               // optional outline
  .attr('stroke-width', d => isActive(d) ? 1.25 : 0.5); // optional emphasis

          link = link.data(linksData, (d) => `${d.source.id}-${d.target.id}`);
          link.exit().remove();
          link = link.enter().append("line").attr("stroke-width", STROKE).merge(link);

          text = text.data(nodesData, (d) => d.label);
          text.exit().remove();
          text = text
            .enter()
            .append("text")
            .text((d) => shorten(d.label.replace(/_*/g, ""), MAX_LABEL_LENGTH))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

            text
  .attr('fill', nodeColor)
  .attr('opacity', nodeOpacity);

          node.attr("active", (d) => isCurrentPath(d.path) ? true : null);
          text.attr("active", (d) => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);
          simulation.alpha(1).restart();
          simulation.stop();

          for (let i = 0; i < TICKS; i++) {
            simulation.tick();
          }

          ticked();
        };

        const zoomHandler = d3.zoom().scaleExtent([0.2, 3]).on("zoom", resize);

        zoomHandler(svg);
        restart();

        function isCurrentPath(notePath) {
  if (!notePath) return false;
  const norm = s => String(s).replace(/\/+$/, '');
  return norm(window.location.pathname) === norm(notePath);
}

        function shorten(str, maxLen, separator = ' ') {
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
      }
    }
  </script>
</div>
